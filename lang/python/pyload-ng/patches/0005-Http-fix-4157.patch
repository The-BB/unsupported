From c594a1cb2ee0b935d99be3a97ccbebb98577deba Mon Sep 17 00:00:00 2001
From: GammaC0de <gammac0de@users.noreply.github.com>
Date: Sun, 5 Jun 2022 23:56:51 +0300
Subject: [PATCH 05/25] [Http] fix #4157

---
 src/pyload/plugins/downloaders/Http.py | 83 +++++++++++++-------------
 1 file changed, 40 insertions(+), 43 deletions(-)

diff --git a/src/pyload/plugins/downloaders/Http.py b/src/pyload/plugins/downloaders/Http.py
index 9dda3d085..46b6de02c 100644
--- a/src/pyload/plugins/downloaders/Http.py
+++ b/src/pyload/plugins/downloaders/Http.py
@@ -11,7 +11,7 @@ from ..base.downloader import BaseDownloader
 class Http(BaseDownloader):
     __name__ = "Http"
     __type__ = "downloader"
-    __version__ = "0.12"
+    __version__ = "0.13"
     __status__ = "testing"
 
     __pattern__ = r"(?:jd|pys?)://.+"
@@ -19,7 +19,10 @@ class Http(BaseDownloader):
 
     __description__ = """Download simple http link"""
     __license__ = "GPLv3"
-    __authors__ = [("Walter Purcaro", "vuolter@gmail.com")]
+    __authors__ = [
+        ("Walter Purcaro", "vuolter@gmail.com"),
+        ("GammaC0de", "nitzo2001[AT]yahoo[DOT]com"),
+    ]
 
     def setup(self):
         self.chunk_limit = -1
@@ -34,50 +37,44 @@ class Http(BaseDownloader):
     def process(self, pyfile):
         url = re.sub(r"^(jd|py)", "http", pyfile.url)
 
-        for _i in range(2):
-            try:
-                self.download(url, ref=False, disposition=True)
-
-            except BadHeader as exc:
-                if exc.code not in (401, 403, 404, 410):
-                    raise
-
-            if self.req.code in (404, 410):
-                self.offline()
-
-            elif self.req.code in (401, 403):
-                self.log_debug(
-                    "Auth required", f"Received HTTP status code: {self.req.code}"
-                )
-
-                if _i == 0:
-                    netloc = urllib.parse.urlparse(url).netloc
-                    try:
-                        netloc = netloc.split('@', 2)[1]
-                    except IndexError:
-                        pass
-
-                    if self.account:
-                        logins = dict((x['login'], x['password'])
-                                      for x in self.account.get_all_accounts())
-                    else:
-                        logins = {}
-
-                    if netloc in logins:
-                        self.log_debug(f"Logging on to {netloc}")
-                        self.req.add_auth(logins[netloc])
-
-                    else:
-                        auth = self.get_password()
-                        if ":" in auth:
-                            self.req.add_auth(auth)
-                        else:
-                            self.fail(self._("Authorization required"))
+        netloc = urllib.parse.urlparse(url).netloc
+        try:
+            auth, netloc = netloc.split('@', 2)
+        except ValueError:
+            auth = None
+
+        if auth is None:
+            password = self.get_password()
+            if ":" in password:
+                auth = password
+                self.log_debug(f"Logging on to {netloc} using credentials specified in the package password")
+
+            else:
+                if self.account:
+                    logins = dict((x['login'], x['password'])
+                                  for x in self.account.get_all_accounts())
                 else:
-                    self.fail(self._("Authorization required"))
+                    logins = {}
+
+                if netloc in logins:
+                    auth = logins[netloc]
+                    self.log_debug(f"Logging on to {netloc} using the account plugin")
+
+            if auth is not None:
+                self.req.add_auth(auth)
+
+        else:
+            self.log_debug(f"Logging on to {netloc} using credentials specified in the URL")
+
+        try:
+            self.download(url, ref=False, disposition=True)
+
+        except BadHeader as exc:
+            if exc.code == 401:
+                self.fail(self._("Unauthorized"))
 
             else:
-                break
+                raise
 
         self.check_download()
 
-- 
2.30.2

