From 5e662598b164f258f95d73ae7ca22db5a2cb28ee Mon Sep 17 00:00:00 2001
From: GammaC0de <gammac0de@users.noreply.github.com>
Date: Tue, 11 May 2021 22:57:16 +0300
Subject: [PATCH 019/150] [MegaCoNz] sync with stable, use cryptography package
 instead of PyCryptodome

---
 src/pyload/plugins/accounts/MegaCoNz.py       |  94 +++++++----
 .../plugins/decrypters/MegaCoNzFolder.py      |  47 ++----
 src/pyload/plugins/downloaders/MegaCoNz.py    | 159 ++++++++++--------
 3 files changed, 164 insertions(+), 136 deletions(-)

--- a/src/pyload/plugins/accounts/MegaCoNz.py
+++ b/src/pyload/plugins/accounts/MegaCoNz.py
@@ -1,6 +1,8 @@
 # -*- coding: utf-8 -*-
 
-import Cryptodome.PublicKey.RSA
+import hashlib
+
+from pyload.core.utils.convert import to_bytes, to_str
 
 from ..base.account import BaseAccount
 from ..downloaders.MegaCoNz import MegaClient, MegaCrypto
@@ -9,7 +11,7 @@ from ..downloaders.MegaCoNz import MegaC
 class MegaCoNz(BaseAccount):
     __name__ = "MegaCoNz"
     __type__ = "account"
-    __version__ = "0.06"
+    __version__ = "0.08"
     __status__ = "testing"
 
     __description__ = """Mega.co.nz account plugin"""
@@ -23,14 +25,14 @@ class MegaCoNz(BaseAccount):
 
         mega = MegaClient(self, None)
 
-        res = mega.api_response(a="uq", xfer=1, pro=1)  #: user quota details
+        res = mega.api_request(a="uq", xfer=1, pro=1)  #: user quota details
         if isinstance(res, dict):
             premium = res.get("utype", 0) > 0
             if premium:
                 validuntil = res.get("suntil", None)
                 trafficleft = (
                     res.get("mxfer", 0) - res.get("caxfer", 0) - res.get("csxfer", 0)
-                ) >> 10
+                )
 
             # if res['rtt']:
             #     self.log_debug(f"Tranfare history:{res['tah']}")
@@ -42,13 +44,14 @@ class MegaCoNz(BaseAccount):
         }
 
     def signin(self, user, password, data):
+        user = user.lower()
         mega = MegaClient(self, None)
 
         mega_session_cache = self.db.retrieve("mega_session_cache") or {}
         if user in mega_session_cache:
             data["mega_session_id"] = mega_session_cache[user]
 
-            res = mega.api_response(a="ug", xfer=1, pro=1)  #: ug is for user details
+            res = mega.api_request(a="ug", xfer=1, pro=1)  #: ug is for user details
             if isinstance(res, dict) and res.get("email", None) == user:
                 self.skip_login()
 
@@ -59,13 +62,28 @@ class MegaCoNz(BaseAccount):
         sid = None
         data["mega_session_id"] = sid
 
-        password_key = self.get_password_key(password)
-        user_hash = self.get_user_hash(user, password_key)
+        res = mega.api_request(a="us0", user=user)  #: us0 is `prelogin` command
+        if res["v"] == 1:  #: v1 account
+            password_key = self.get_password_key(password)
+            user_hash = self.get_user_hash_v1(user, password_key)
+
+        elif res["v"] == 2:  #: v2 account
+            salt = MegaCrypto.base64_decode(res["s"])
+            pbkdf = hashlib.pbkdf2_hmac("SHA512", to_bytes(password, "utf-8"), salt, 100_000, 32)
+
+            password_key = MegaCrypto.bytes_to_a32(pbkdf[:16])
+            user_hash = (
+                to_str(MegaCrypto.base64_encode(pbkdf[16:]), "ascii").replace("=", "")
+            )
 
-        res = mega.api_response(a="us", user=user, uh=user_hash)
-        if isinstance(res, int):
+        else:
+            self.log_error(
+                self._("Unsupported user account version ({})").format(res["v"])
+            )
             self.fail_login()
-        elif isinstance(res, dict) and "e" in res:
+
+        res = mega.api_request(a="us", user=user, uh=user_hash)  #: us if for user sign-in
+        if isinstance(res, int) or isinstance(res, dict) and "e" in res:
             self.fail_login()
 
         master_key = MegaCrypto.decrypt_key(res["k"], password_key)
@@ -73,8 +91,10 @@ class MegaCoNz(BaseAccount):
         if "tsid" in res:
             tsid = MegaCrypto.base64_decode(res["tsid"])
             if (
-                MegaCrypto.a32_to_str(
-                    MegaCrypto.encrypt_key(MegaCrypto.str_to_a32(tsid[:16]), master_key)
+                MegaCrypto.a32_to_bytes(
+                    MegaCrypto.encrypt_key(
+                        MegaCrypto.bytes_to_a32(tsid[:16]), master_key
+                    )
                 )
                 == tsid[-16:]
             ):
@@ -84,30 +104,34 @@ class MegaCoNz(BaseAccount):
                 self.fail_login()
 
         elif "csid" in res:
-            privk = MegaCrypto.a32_to_str(
+            privk = MegaCrypto.a32_to_bytes(
                 MegaCrypto.decrypt_key(res["privk"], master_key)
             )
-            rsa_private_key = [int(0), int(0), int(0), int(0)]
+            rsa_private_key = [0, 0, 0, 0]
 
             for i in range(4):
-                l = ((ord(privk[0]) * 256 + ord(privk[1]) + 7) // 8) + 2
+                l = ((privk[0] * 256 + privk[1] + 7) // 8) + 2
+                if l > len(privk):
+                    self.fail_login()
                 rsa_private_key[i] = self.mpi_to_int(privk[:l])
                 privk = privk[l:]
 
-            encrypted_sid = self.mpi_to_int(MegaCrypto.base64_decode(res["csid"]))
-            rsa = Cryptodome.PublicKey.RSA.construct(
-                (
-                    rsa_private_key[0] * rsa_private_key[1],
-                    int(0),
+            if len(privk) >= 16:
+                self.fail_login()
+
+            encrypted_sid = self.mpi_to_int(
+                MegaCrypto.base64_decode(res["csid"])
+            )
+            sid = "{:x}".format(
+                pow(
+                    encrypted_sid,
                     rsa_private_key[2],
-                    rsa_private_key[0],
-                    rsa_private_key[1],
+                    rsa_private_key[0] * rsa_private_key[1],
                 )
             )
-            sid = "{:x}".format(rsa._decrypt(encrypted_sid))
             sid = "0" * (-len(sid) % 2) + sid
-            sid = "".join(chr(int(sid[i : i + 2], 16)) for i in range(0, len(sid), 2))
-            sid = MegaCrypto.base64_encode(sid[:43]).replace("=", "")
+            sid = bytes([(int(sid[i : i + 2], 16)) for i in range(0, len(sid), 2)])
+            sid = to_str(MegaCrypto.base64_encode(sid[:43]), "ascii").replace("=", "")
 
         else:
             self.fail_login()
@@ -117,10 +141,10 @@ class MegaCoNz(BaseAccount):
         self.db.store("mega_session_cache", mega_session_cache)
 
     def get_password_key(self, password):
-        password_key = MegaCrypto.a32_to_str(
+        password_key = MegaCrypto.a32_to_bytes(
             [0x93C467E3, 0x7DB0C7A4, 0xD1BE3F81, 0x0152CB56]
         )
-        password_a32 = MegaCrypto.str_to_a32(password)
+        password_a32 = MegaCrypto.bytes_to_a32(to_bytes(password, "utf-8"))
         for c in range(0x10000):
             for j in range(0, len(password_a32), 4):
                 key = [0, 0, 0, 0]
@@ -129,26 +153,24 @@ class MegaCoNz(BaseAccount):
                         key[i] = password_a32[i + j]
                 password_key = MegaCrypto.cbc_encrypt(password_key, key)
 
-        return MegaCrypto.str_to_a32(password_key)
+        return MegaCrypto.bytes_to_a32(password_key)
 
-    def get_user_hash(self, user, password_key):
-        user_a32 = MegaCrypto.str_to_a32(user)
+    def get_user_hash_v1(self, user, password_key):
+        user_a32 = MegaCrypto.bytes_to_a32(to_bytes(user, "utf-8"))
         user_hash = [0, 0, 0, 0]
         for i in range(len(user_a32)):
             user_hash[i % 4] ^= user_a32[i]
 
-        user_hash = MegaCrypto.a32_to_str(user_hash)
+        user_hash = MegaCrypto.a32_to_bytes(user_hash)
         for i in range(0x4000):
             user_hash = MegaCrypto.cbc_encrypt(user_hash, password_key)
 
-        user_hash = MegaCrypto.str_to_a32(user_hash)
+        user_hash = MegaCrypto.bytes_to_a32(user_hash)
 
-        return MegaCrypto.a32_to_base64((user_hash[0], user_hash[2]))
+        return to_str(MegaCrypto.a32_to_base64((user_hash[0], user_hash[2])), "ascii")
 
     def mpi_to_int(self, s):
         """
         Convert GCRYMPI_FMT_PGP bignum format to integer.
         """
-        return int(
-            "".join("{:2x}".format(ord(s[2:][x])) for x in range(len(s[2:]))), 16
-        )
+        return int("".join("{:02x}".format(s[2:][x]) for x in range(len(s[2:]))), 16)
--- a/src/pyload/plugins/decrypters/MegaCoNzFolder.py
+++ b/src/pyload/plugins/decrypters/MegaCoNzFolder.py
@@ -1,35 +1,12 @@
 # -*- coding: utf-8 -*-
 
+from pyload.core.utils.convert import to_str
+
 from pyload.core.network.cookie_jar import CookieJar
 from pyload.core.network.http.http_request import HTTPRequest
 
 from ..base.decrypter import BaseDecrypter
 from ..downloaders.MegaCoNz import MegaClient, MegaCrypto
-from pyload.core.network.exceptions import Abort
-
-class BIGHTTPRequest(HTTPRequest):
-    """
-    Overcome HTTPRequest's load() size limit to allow
-    loading very big web pages by overrding HTTPRequest's write() function
-    """
-
-    # @TODO: Add 'limit' parameter to HTTPRequest in v0.4.10
-    def __init__(self, cookies=None, options=None, limit=2000000):
-        self.limit = limit
-        HTTPRequest.__init__(self, cookies=cookies, options=options)
-
-    def write(self, buf):
-        """ writes response """
-        if self.limit and self.rep.tell() > self.limit or self.abort:
-            rep = self.getResponse()
-            if self.abort:
-                raise Abort()
-            f = open("response.dump", "wb")
-            f.write(rep)
-            f.close()
-            raise Exception("Loaded Url exceeded limit")
-
-        self.rep.write(buf)
 
 
 class MegaCoNzFolder(BaseDecrypter):
@@ -38,7 +15,7 @@ class MegaCoNzFolder(BaseDecrypter):
     __version__ = "0.24"
     __status__ = "testing"
 
-    __pattern__ = r"(https?://(?:www\.)?mega(\.co)?\.nz/|mega:|chrome:.+?)#F!(?P<ID>[\w^_]+)!(?P<KEY>[\w,\-=]+)"
+    __pattern__ = r"(?:https?://(?:www\.)?mega(?:\.co)?\.nz/|mega:|chrome:.+?)(?:folder/|#F!)(?P<ID>[\w^_]+)[!#](?P<KEY>[\w,\-=]+)"
     __config__ = [
         ("enabled", "bool", "Activated", True),
         ("use_premium", "bool", "Use premium account if available", True),
@@ -63,10 +40,11 @@ class MegaCoNzFolder(BaseDecrypter):
         except Exception:
             pass
 
-        self.req.http = BIGHTTPRequest(
+        self.req.http = HTTPRequest(
             cookies=CookieJar(None),
-            options=self.pyload.requestFactory.getOptions(),
-            limit=10000000)
+            options=self.pyload.request_factory.get_options(),
+            limit=10_000_000,
+        )
 
     def decrypt(self, pyfile):
         id = self.info["pattern"]["ID"]
@@ -81,7 +59,7 @@ class MegaCoNzFolder(BaseDecrypter):
         mega = MegaClient(self, id)
 
         #: F is for requesting folder listing (kind like a `ls` command)
-        res = mega.api_response(a="f", c=1, r=1, ca=1, ssl=1)
+        res = mega.api_request(a="f", c=1, r=1, ca=1, ssl=1)
 
         if isinstance(res, int):
             mega.check_error(res)
@@ -89,12 +67,15 @@ class MegaCoNzFolder(BaseDecrypter):
             mega.check_error(res["e"])
 
         def get_node_key(k):
-            return MegaCrypto.base64_encode(
-                MegaCrypto.a32_to_str(MegaCrypto.decrypt_key(k, master_key))
+            return to_str(
+                MegaCrypto.base64_encode(
+                    MegaCrypto.a32_to_bytes(MegaCrypto.decrypt_key(k, master_key))
+                ),
+                "ascii",
             )
 
         urls = [
-            self._("https://mega.co.nz/#N!{}!{}###n={}").format(
+            "https://mega.co.nz/#N!{}!{}###n={}".format(
                 f["h"], get_node_key(f["k"][f["k"].index(":") + 1 :]), id
             )
             for f in res["f"]
--- a/src/pyload/plugins/downloaders/MegaCoNz.py
+++ b/src/pyload/plugins/downloaders/MegaCoNz.py
@@ -7,11 +7,11 @@ import random
 import re
 import struct
 
-import Cryptodome.Cipher.AES
-import Cryptodome.Util.Counter
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
 
 from pyload.core.network.http.exceptions import BadHeader
-from pyload.core.utils.old import decode
+from pyload.core.utils.convert import to_bytes
 
 from ..base.downloader import BaseDownloader
 from ..helpers import exists
@@ -44,51 +44,80 @@ from ..helpers import exists
 # EREAD               (-21): Read failed
 # EAPPKEY             (-22): Invalid application key; request not processed
 # ESSL                (-23): SSL verification failed
+# EGOINGOVERQUOTA     (-24): Not enough quota
+# EMFAREQUIRED        (-26): Multi-factor authentication required
 
 
 class MegaCrypto:
     @staticmethod
     def base64_decode(data):
+        data = to_bytes(data, "ascii")
         #: Add padding, we need a string with a length multiple of 4
-        data += "=" * (-len(data) % 4)
-        return base64.b64decode(str(data), "-_")
+        data += b"=" * (-len(data) % 4)
+        return base64.b64decode(data, b"-_")
 
     @staticmethod
     def base64_encode(data):
-        return base64.b64encode(data, "-_")
+        return base64.b64encode(data, b"-_")
 
     @staticmethod
-    def a32_to_str(a):
+    def a32_to_bytes(a):
         return struct.pack(">{}I".format(len(a)), *a)  #: big-endian, unsigned int)
 
     @staticmethod
-    def str_to_a32(s):
+    def bytes_to_a32(s):
         # Add padding, we need a string with a length multiple of 4
-        s += "\0" * (-len(s) % 4)
+        s += b"\0" * (-len(s) % 4)
         #: big-endian, unsigned int
         return struct.unpack(">{}I".format(len(s) // 4), s)
 
     @staticmethod
     def a32_to_base64(a):
-        return MegaCrypto.base64_encode(MegaCrypto.a32_to_str(a))
+        return MegaCrypto.base64_encode(MegaCrypto.a32_to_bytes(a))
 
     @staticmethod
     def base64_to_a32(s):
-        return MegaCrypto.str_to_a32(MegaCrypto.base64_decode(s))
+        return MegaCrypto.bytes_to_a32(MegaCrypto.base64_decode(s))
 
     @staticmethod
     def cbc_decrypt(data, key):
-        cbc = Cryptodome.Cipher.AES.new(
-            MegaCrypto.a32_to_str(key), Cryptodome.Cipher.AES.MODE_CBC, "\0" * 16
+        cipher = Cipher(
+            algorithms.AES(MegaCrypto.a32_to_bytes(key)),
+            modes.CBC(b"\0" * 16),
+            backend=default_backend(),
         )
-        return cbc.decrypt(data)
+        decryptor = cipher.decryptor()
+        return decryptor.update(data) + decryptor.finalize()
 
     @staticmethod
     def cbc_encrypt(data, key):
-        cbc = Cryptodome.Cipher.AES.new(
-            MegaCrypto.a32_to_str(key), Cryptodome.Cipher.AES.MODE_CBC, "\0" * 16
+        cipher = Cipher(
+            algorithms.AES(MegaCrypto.a32_to_bytes(key)),
+            modes.CBC(b"\0" * 16),
+            backend=default_backend(),
         )
-        return cbc.encrypt(data)
+        encryptor = cipher.encryptor()
+        return encryptor.update(data) + encryptor.finalize()
+
+    @staticmethod
+    def ecb_decrypt(data, key):
+        cipher = Cipher(
+            algorithms.AES(MegaCrypto.a32_to_bytes(key)),
+            modes.ECB(),
+            backend=default_backend(),
+        )
+        decryptor = cipher.decryptor()
+        return decryptor.update(data) + decryptor.finalize()
+
+    @staticmethod
+    def ecb_encrypt(data, key):
+        cipher = Cipher(
+            algorithms.AES(MegaCrypto.a32_to_bytes(key)),
+            modes.ECB(),
+            backend=default_backend(),
+        )
+        encryptor = cipher.encryptor()
+        return encryptor.update(data) + encryptor.finalize()
 
     @staticmethod
     def get_cipher_key(key):
@@ -112,8 +141,8 @@ class MegaCrypto:
 
         #: Data is padded, 0-bytes must be stripped
         return (
-            json.loads(re.search(r"{.+}", attr).group(0))
-            if attr[:6] == 'MEGA{"'
+            json.loads(re.search(rb"{.+}", attr).group(0))
+            if attr[:6] == b'MEGA{"'
             else False
         )
 
@@ -123,27 +152,15 @@ class MegaCrypto:
         Decrypt an encrypted key ('k' member of a node)
         """
         data = MegaCrypto.base64_decode(data)
-        return sum(
-            (
-                MegaCrypto.str_to_a32(MegaCrypto.cbc_decrypt(data[i : i + 16], key))
-                for i in range(0, len(data), 16)
-            ),
-            (),
-        )
+        return MegaCrypto.bytes_to_a32(MegaCrypto.ecb_decrypt(data, key))
 
     @staticmethod
     def encrypt_key(data, key):
         """
         Encrypt a decrypted key.
         """
-        data = MegaCrypto.base64_decode(data)
-        return sum(
-            (
-                MegaCrypto.str_to_a32(MegaCrypto.cbc_encrypt(data[i : i + 16], key))
-                for i in range(0, len(data), 16)
-            ),
-            (),
-        )
+        data = MegaCrypto.a32_to_bytes(data)
+        return MegaCrypto.bytes_to_a32(MegaCrypto.ecb_encrypt(data, key))
 
     @staticmethod
     def get_chunks(size):
@@ -154,13 +171,13 @@ class MegaCrypto:
         chunk_size = 0x20000
 
         while chunk_start + chunk_size < size:
-            yield (chunk_start, chunk_size)
+            yield chunk_start, chunk_size
             chunk_start += chunk_size
             if chunk_size < 0x100000:
                 chunk_size += 0x20000
 
         if chunk_start < size:
-            yield (chunk_start, size - chunk_start)
+            yield chunk_start, size - chunk_start
 
     class Checksum:
         """
@@ -169,30 +186,38 @@ class MegaCrypto:
 
         def __init__(self, key):
             k, iv, meta_mac = MegaCrypto.get_cipher_key(key)
-            self.hash = "\0" * 16
-            self.key = MegaCrypto.a32_to_str(k)
-            self.iv = MegaCrypto.a32_to_str(iv[0:2] * 2)
-            self.AES = Cryptodome.Cipher.AES.new(
-                self.key, mode=Cryptodome.Cipher.AES.MODE_CBC, IV=self.hash
+            self.hash = b"\0" * 16
+            self.key = MegaCrypto.a32_to_bytes(k)
+            self.iv = MegaCrypto.a32_to_bytes(iv[0:2] * 2)
+
+            cipher = Cipher(
+                algorithms.AES(self.key),
+                modes.CBC(self.hash),
+                backend=default_backend(),
             )
+            self.AES = cipher.encryptor()
 
         def update(self, chunk):
-            cbc = Cryptodome.Cipher.AES.new(
-                self.key, mode=Cryptodome.Cipher.AES.MODE_CBC, IV=self.iv
+            cipher = Cipher(
+                algorithms.AES(self.key), modes.CBC(self.iv), backend=default_backend()
             )
+            encryptor = cipher.encryptor()
+
             for j in range(0, len(chunk), 16):
-                block = chunk[j : j + 16].ljust(16, "\0")
-                hash = cbc.encrypt(block)
+                block = chunk[j : j + 16].ljust(16, b"\0")
+                hash = encryptor.update(block)
+
+            encryptor.finalize()
 
-            self.hash = self.AES.encrypt(hash)
+            self.hash = self.AES.update(hash)
 
         def digest(self):
             """
             Return the **binary** (non-printable) CBC-MAC of the message that has been
             authenticated so far.
             """
-            d = MegaCrypto.str_to_a32(self.hash)
-            return (d[0] ^ d[1], d[2] ^ d[3])
+            d = MegaCrypto.bytes_to_a32(self.hash)
+            return d[0] ^ d[1], d[2] ^ d[3]
 
         def hexdigest(self):
             """
@@ -200,7 +225,7 @@ class MegaCrypto:
             so far.
             """
             return "".join(
-                "{:2x}".format(ord(x)) for x in MegaCrypto.a32_to_str(self.digest())
+                "{:2x}".format(ord(x)) for x in MegaCrypto.a32_to_bytes(self.digest())
             )
 
         @staticmethod
@@ -216,7 +241,7 @@ class MegaClient:
         self._ = plugin._
         self.node_id = node_id
 
-    def api_response(self, **kwargs):
+    def api_request(self, **kwargs):
         """
         Dispatch a call to the api, see https://mega.co.nz/#developers.
         """
@@ -268,10 +293,10 @@ class MegaClient:
         if ecode in (9, 16, 21):
             self.plugin.offline()
 
-        elif ecode in (3, 13, 17, 18, 19):
+        elif ecode in (3, 13, 17, 18, 19, 24):
             self.plugin.temp_offline()
 
-        elif ecode in (1, 4, 6, 10, 15, 21):
+        elif ecode in (1, 4, 6, 10, 15):
             self.plugin.retry(
                 max_tries=5,
                 wait_time=30,
@@ -285,10 +310,10 @@ class MegaClient:
 class MegaCoNz(BaseDownloader):
     __name__ = "MegaCoNz"
     __type__ = "downloader"
-    __version__ = "0.52"
+    __version__ = "0.55"
     __status__ = "testing"
 
-    __pattern__ = r"(https?://(?:www\.)?mega(\.co)?\.nz/|mega:|chrome:.+?)#(?P<TYPE>N|)!(?P<ID>[\w^_]+)!(?P<KEY>[\w\-,=]+)(?:###n=(?P<OWNER>[\w^_]+))?"
+    __pattern__ = r"(?:https?://(?:www\.)?mega(?:\.co)?\.nz/|mega:|chrome:.+?)(?:file/|#(?P<TYPE>N|)!)(?P<ID>[\w^_]+)[!#](?P<KEY>[\w\-,=]+)(?:###n=(?P<OWNER>[\w^_]+))?"
     __config__ = [("enabled", "bool", "Activated", True)]
 
     __description__ = """Mega.co.nz downloader plugin"""
@@ -306,12 +331,12 @@ class MegaCoNz(BaseDownloader):
         Decrypts and verifies checksum to the file at 'last_download'.
         """
         k, iv, meta_mac = MegaCrypto.get_cipher_key(key)
-        ctr = Cryptodome.Util.Counter.new(
-            128, initial_value=((iv[0] << 32) + iv[1]) << 64
-        )
-        cipher = Cryptodome.Cipher.AES.new(
-            MegaCrypto.a32_to_str(k), Cryptodome.Cipher.AES.MODE_CTR, counter=ctr
+        cipher = Cipher(
+            algorithms.AES(MegaCrypto.a32_to_bytes(k)),
+            modes.CTR(MegaCrypto.a32_to_bytes(iv)),
+            backend=default_backend(),
         )
+        decryptor = cipher.decryptor()
 
         self.pyfile.set_status("decrypting")
         self.pyfile.set_progress(0)
@@ -345,15 +370,16 @@ class MegaCoNz(BaseDownloader):
             if not buf:
                 break
 
-            chunk = cipher.decrypt(buf)
+            chunk = decryptor.update(buf)
             df.write(chunk)
 
             progress += chunk_size
-            self.pyfile.set_progress((100 // encrypted_size) * progress)
+            self.pyfile.set_progress((100 * progress) // encrypted_size)
 
             if checksum_activated and check_checksum:
                 cbc_mac.update(chunk)
 
+        df.write(decryptor.finalize())
         self.pyfile.set_progress(100)
 
         f.close()
@@ -380,7 +406,7 @@ class MegaCoNz(BaseDownloader):
                 )
                 self.checksum_failed(file_decrypted, self._("Checksums do not match"))
 
-        self.last_download = decode(file_decrypted)
+        self.last_download = file_decrypted
 
     def checksum_failed(self, local_file, msg):
         check_action = self.config.get(
@@ -432,7 +458,7 @@ class MegaCoNz(BaseDownloader):
     def process(self, pyfile):
         id = self.info["pattern"]["ID"]
         key = self.info["pattern"]["KEY"]
-        public = self.info["pattern"]["TYPE"] == ""
+        public = self.info["pattern"]["TYPE"] in ("", None)
         owner = self.info["pattern"]["OWNER"]
 
         if not public and not owner:
@@ -456,11 +482,10 @@ class MegaCoNz(BaseDownloader):
         )
 
         #: G is for requesting a download url
-        #: This is similar to the calls in the mega js app, documentation is very bad
         if public:
-            res = mega.api_response(a="g", g=1, p=id, ssl=1)
+            res = mega.api_request(a="g", g=1, p=id, ssl=1)
         else:
-            res = mega.api_response(a="g", g=1, n=id, ssl=1)
+            res = mega.api_request(a="g", g=1, n=id, ssl=1)
 
         if isinstance(res, int):
             mega.check_error(res)
@@ -471,7 +496,7 @@ class MegaCoNz(BaseDownloader):
         if not attr:
             self.fail(self._("Decryption failed"))
 
-        self.log_debug(f"Decrypted Attr: {decode(attr)}")
+        self.log_debug(f"Decrypted Attr: {attr}")
 
         name = attr["n"]
 
