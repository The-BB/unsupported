From 737968c1e0298c32aa99435be878823dd9c4fa5a Mon Sep 17 00:00:00 2001
From: GammaC0de <gammac0de@users.noreply.github.com>
Date: Fri, 14 May 2021 22:26:57 +0300
Subject: [PATCH 032/150] [FileboomMe] sync with stable

---
 src/pyload/plugins/accounts/FileboomMe.py    | 170 ++++++++++++++++++
 src/pyload/plugins/downloaders/FileboomMe.py | 178 +++++++++++++------
 2 files changed, 291 insertions(+), 57 deletions(-)
 create mode 100644 src/pyload/plugins/accounts/FileboomMe.py

--- /dev/null
+++ b/src/pyload/plugins/accounts/FileboomMe.py
@@ -0,0 +1,170 @@
+# -*- coding: utf-8 -*-
+
+import json
+import re
+
+from pyload.core.datatypes.pyfile import PyFile
+from pyload.core.network.HTTPRequest import BadHeader
+from pyload.core.network.request_factory import get_url
+
+from ..anticaptchas.ReCaptcha import ReCaptcha
+from ..base.account import BaseAccount
+from ..base.captcha import BaseCaptcha
+
+
+class FileboomMe(BaseAccount):
+    __name__ = "FileboomMe"
+    __type__ = "account"
+    __version__ = "0.02"
+    __status__ = "testing"
+
+    __description__ = """Fileboom.me account plugin"""
+    __license__ = "GPLv3"
+    __authors__ = [("GammaC0de", "nitzo2001[AT]yahoo[DOT]com")]
+
+    RECAPTCHA_KEY = "6LcYcN0SAAAAABtMlxKj7X0hRxOY8_2U86kI1vbb"
+
+    API_URL = "https://fileboom.me/api/v2/"
+    #: Actually this is Keep2ShareCc API, see https://keep2share.github.io/api/ https://github.com/keep2share/api
+
+    @classmethod
+    def api_response(cls, method, **kwargs):
+        html = get_url(cls.API_URL + method,
+                       post=json.dumps(kwargs))
+        return json.loads(html)
+
+    def grab_info(self, user, password, data):
+        json_data = self.api_response("AccountInfo", auth_token=data['token'])
+
+        return {'validuntil': json_data['account_expires'],
+                'trafficleft': json_data['available_traffic'],
+                'premium': True if json_data['account_expires'] else False}
+
+    def signin(self, user, password, data):
+        if 'token' in data:
+            try:
+                json_data = self.api_response("test", auth_token=data['token'])
+
+            except BadHeader as exc:
+                if exc.code == 403:  #: Session expired
+                    pass
+
+                else:
+                    raise
+            else:
+                self.skip_login()
+
+        try:
+            json_data = self.api_response("login", username=user, password=password)
+
+        except BadHeader as exc:
+            if exc.code == 406:  #: Captcha needed
+                # dummy pyfile
+                pyfile = PyFile(self.pyload.files, -1, "https://fileboom.me", "https://fileboom.me", 0, 0, "", self.classname, -1, -1)
+                pyfile.plugin = self
+
+                errors = [json.loads(m.group(0)).get('errorCode', 0) for m in re.finditer(r'{[^}]+}', exc.content)]
+                if 33 in errors:  #: ERROR_RE_CAPTCHA_REQUIRED
+                    #: Recaptcha
+                    self.captcha = ReCaptcha(pyfile)
+                    for i in range(10):
+                        json_data = self.api_response("RequestReCaptcha")
+                        if json_data['code'] != 200:
+                            self.log_error(_("Request reCAPTCHA API failed"))
+                            self.fail_login(_("Request reCAPTCHA API failed"))
+
+                        re_captcha_response, _ = self.captcha.challenge(self.RECAPTCHA_KEY, version="2js", secure_token=False)
+                        try:
+                            json_data = self.api_response("login",
+                                                          username=user,
+                                                          password=password,
+                                                          re_captcha_challenge=json_data['challenge'],
+                                                          re_captcha_response=re_captcha_response)
+
+                        except BadHeader as exc:
+                            if exc.code == 406:
+                                errors = [json.loads(m.group(0)).get('errorCode', 0) for m in re.finditer(r'{[^}]+}', exc.content)]
+                                if 31 in errors:  #: ERROR_CAPTCHA_INVALID
+                                    self.captcha.invalid()
+                                    continue
+
+                                else:
+                                    self.log_error(exc.content)
+                                    self.fail_login(exc.content)
+
+                            else:
+                                self.log_error(exc.content)
+                                self.fail_login(exc.content)
+
+                        else:
+                            self.captcha.correct()
+                            data['token'] = json_data['auth_token']
+                            break
+
+                    else:
+                        self.log_error(_("Max captcha retries reached"))
+                        self.fail_login(_("Max captcha retries reached"))
+
+                elif 30 in errors:  #: ERROR_CAPTCHA_REQUIRED
+                    #: Normal captcha
+                    self.captcha = BaseCaptcha(pyfile)
+                    for i in range(10):
+                        json_data = self.api_response("RequestCaptcha")
+                        if json_data['code'] != 200:
+                            self.log_error(self._("Request captcha API failed"))
+                            self.fail_login(self._("Request captcha API failed"))
+
+                        captcha_response = self.captcha.decrypt(json_data['captcha_url'])
+                        try:
+                            json_data = self.api_response("login",
+                                                          username=user,
+                                                          password=password,
+                                                          captcha_challenge=json_data['challenge'],
+                                                          captcha_response=captcha_response)
+
+                        except BadHeader as exc:
+                            if exc.code == 406:
+                                errors = [json.loads(m.group(0)).get('errorCode', 0) for m in re.finditer(r'{[^}]+}', exc.content)]
+                                if 31 in errors:  #: ERROR_CAPTCHA_INVALID
+                                    self.captcha.invalid()
+                                    continue
+
+                                else:
+                                    self.log_error(exc.content)
+                                    self.fail_login(exc.content)
+
+                            else:
+                                self.log_error(exc.content)
+                                self.fail_login(exc.content)
+
+                        else:
+                            self.captcha.correct()
+                            data['token'] = json_data['auth_token']
+                            break
+
+                    else:
+                        self.log_error(self._("Max captcha retries reached"))
+                        self.fail_login(self._("Max captcha retries reached"))
+
+                else:
+                    self.log_error(exc.content)
+                    self.fail_login(exc.content)
+
+            else:
+                self.log_error(exc.content)
+                self.fail_login(exc.content)
+
+        else:
+            #: No captcha
+            data['token'] = json_data['auth_token']
+
+    """
+     @NOTE: below are methods
+      necessary for captcha to work with account plugins
+    """
+    def check_status(self):
+        pass
+
+    def retry_captcha(self, attemps=10, wait=1, msg="Max captcha retries reached"):
+        self.captcha.invalid()
+        self.fail_login(msg=self._("Invalid captcha"))
--- a/src/pyload/plugins/downloaders/FileboomMe.py
+++ b/src/pyload/plugins/downloaders/FileboomMe.py
@@ -1,15 +1,19 @@
 # -*- coding: utf-8 -*-
 
+import json
 import re
 import urllib.parse
 
+from pyload.core.network.http.exceptions import BadHeader
+from pyload.core.network.request_factory import get_url
+
 from ..base.simple_downloader import SimpleDownloader
 
 
 class FileboomMe(SimpleDownloader):
     __name__ = "FileboomMe"
     __type__ = "downloader"
-    __version__ = "0.08"
+    __version__ = "0.11"
     __status__ = "testing"
 
     __pattern__ = r"https?://f(?:ile)?boom\.me/file/(?P<ID>\w+)"
@@ -23,16 +27,36 @@ class FileboomMe(SimpleDownloader):
 
     __description__ = """Fileboom.me downloader plugin"""
     __license__ = "GPLv3"
-    __authors__ = [("GammaC0de", None)]
-
-    NAME_PATTERN = r'<i class="icon-download"></i>\s*(?P<N>.+?)\s*<'
-    SIZE_PATTERN = r"File size: (?P<S>[\d.,]+) (?P<U>[\w^_]+)"
-    OFFLINE_PATTERN = r">This file is no longer available"
+    __authors__ = [("GammaC0de", "nitzo2001[AT]yahoo[DOT]com")]
 
-    WAIT_PATTERN = r'<div class="tik-tak">([\d:]+)'
-    LINK_PATTERN = r"/file/url\.html\?file=\w+"
+    API_URL = "https://fileboom.me/api/v2/"
+    #: Actually this is Keep2ShareCc API, see https://keep2share.github.io/api/ https://github.com/keep2share/api
 
-    CAPTCHA_PATTERN = r'<img .* src="(/file/captcha.html\?v=\w+)"'
+    @classmethod
+    def api_response(cls, method, **kwargs):
+        html = get_url(cls.API_URL + method, post=json.dumps(kwargs))
+        return json.loads(html)
+
+    @classmethod
+    def api_info(cls, url):
+        file_id = re.match(cls.__pattern__, url).group("ID")
+        file_info = cls.api_response("GetFilesInfo", ids=[file_id], extended_info=False)
+
+        if (
+            file_info["code"] != 200
+            or len(file_info["files"]) == 0
+            or file_info["files"][0].get("is_available", False) is False
+        ):
+            return {"status": 1}
+
+        else:
+            return {
+                "name": file_info["files"][0]["name"],
+                "size": file_info["files"][0]["size"],
+                "md5": file_info["files"][0]["md5"],
+                "access": file_info["files"][0]["access"],
+                "status": 2 if file_info["files"][0]["is_available"] else 1,
+            }
 
     def setup(self):
         self.resume_download = True
@@ -40,59 +64,99 @@ class FileboomMe(SimpleDownloader):
         self.chunk_limit = 1
 
     def handle_free(self, pyfile):
-        post_url = urllib.parse.urljoin(
-            pyfile.url, "/file/" + self.info["pattern"]["ID"]
-        )
+        file_id = self.info["pattern"]["ID"]
 
-        m = re.search(r'data-slow-id="(\w+)"', self.data)
-        if m is not None:
-            self.data = self.load(post_url, post={"slow_id": m.group(1)})
-
-            m = re.search(self.LINK_PATTERN, self.data)
-            if m is not None:
-                self.link = urllib.parse.urljoin(pyfile.url, m.group(0))
+        if self.info["access"] == "premium":
+            self.fail(self._("File can be downloaded by premium users only"))
 
-            else:
-                m = re.search(
-                    r'<input type="hidden" name="uniqueId" value="(\w+)">', self.data
-                )
-                if m is None:
-                    m = re.search(r">\s*Please wait ([\d:]+)", self.data)
-                    if m is not None:
-                        wait_time = 0
-                        for v in re.findall(r"(\d+)", m.group(1), re.I):
-                            wait_time = 60 * wait_time + int(v)
-                        self.wait(wait_time)
-                        self.retry()
+        elif self.info["access"] == "private":
+            self.fail(self._("This is a private file"))
 
-                else:
-                    uniqueId = m.group(1)
-
-                    m = re.search(self.CAPTCHA_PATTERN, self.data)
-                    if m is not None:
-                        captcha = self.captcha.decrypt(
-                            urllib.parse.urljoin(pyfile.url, m.group(1))
-                        )
-                        self.data = self.load(
-                            post_url,
-                            post={
-                                "CaptchaForm[verifyCode]": captcha,
-                                "free": 1,
-                                "freeDownloadRequest": 1,
-                                "uniqueId": uniqueId,
-                            },
+        try:
+            api_data = self.api_response(
+                "GetUrl",
+                file_id=file_id,
+                free_download_key=None,
+                captcha_challenge=None,
+                captcha_response=None,
+            )
+
+        except BadHeader as exc:
+            if exc.code == 406:
+                for i in range(10):
+                    api_data = self.api_response("RequestCaptcha")
+                    if api_data["code"] != 200:
+                        self.fail(self._("Request captcha API failed"))
+
+                    captcha_response = self.captcha.decrypt(api_data["captcha_url"])
+                    try:
+                        api_data = self.api_response(
+                            "GetUrl",
+                            file_id=file_id,
+                            free_download_key=None,
+                            captcha_challenge=api_data["challenge"],
+                            captcha_response=captcha_response,
                         )
 
-                        if "The verification code is incorrect" in self.data:
-                            self.retry_captcha()
+                    except BadHeader as exc:
+                        if exc.code == 406:
+                            api_data = json.loads(exc.content)
+                            if api_data["errorCode"] == 31:  #: ERROR_CAPTCHA_INVALID
+                                self.captcha.invalid()
+                                continue
+
+                            elif (
+                                api_data["errorCode"] == 42
+                            ):  #: ERROR_DOWNLOAD_NOT_AVAILABLE
+                                self.captcha.correct()
+                                self.retry(wait=api_data["errors"][0]["timeRemaining"])
+
+                            else:
+                                self.fail(api_data["message"])
 
                         else:
-                            self.check_errors()
+                            raise
+
+                    else:
+                        self.captcha.correct()
+                        free_download_key = api_data["free_download_key"]
+                        break
+
+                else:
+                    self.fail(self._("Max captcha retries reached"))
+
+                self.wait(api_data["time_wait"])
+
+                api_data = self.api_response(
+                    "GetUrl",
+                    file_id=file_id,
+                    free_download_key=free_download_key,
+                    captcha_challenge=None,
+                    captcha_response=None,
+                )
+
+                if api_data["code"] == 200:
+                    self.download(api_data["url"])
+
+            else:
+                raise
+
+        else:
+            self.download(api_data["url"])
+
+    def handle_premium(self, pyfile):
+        file_id = self.info["pattern"]["ID"]
+
+        if self.info["access"] == "private":
+            self.fail(self._("This is a private file"))
+
+        json_data = self.api_response(
+            "GetUrl",
+            file_id=file_id,
+            free_download_key=None,
+            captcha_challenge=None,
+            captcha_response=None,
+            auth_token=self.account.info["data"]["token"],
+        )
 
-                            self.data = self.load(
-                                post_url, post={"free": 1, "uniqueId": uniqueId}
-                            )
-
-                            m = re.search(self.LINK_PATTERN, self.data)
-                            if m is not None:
-                                self.link = urllib.parse.urljoin(pyfile.url, m.group(0))
+        self.link = json_data["url"]
