From 48dd0fdd0074b1381faddf1aba258c5e0c4b2aab Mon Sep 17 00:00:00 2001
From: GammaC0de <gammac0de@users.noreply.github.com>
Date: Tue, 14 Sep 2021 00:54:29 +0300
Subject: [PATCH 144/150] remove deprecated handle_multi()

---
 src/pyload/plugins/base/multi_downloader.py  |  1 -
 src/pyload/plugins/base/simple_downloader.py | 70 ++++++--------------
 src/pyload/plugins/base/xfs_downloader.py    | 58 ----------------
 3 files changed, 22 insertions(+), 107 deletions(-)

--- a/src/pyload/plugins/base/multi_downloader.py
+++ b/src/pyload/plugins/base/multi_downloader.py
@@ -33,7 +33,6 @@ class MultiDownloader(SimpleDownloader):
     OFFLINE_PATTERN = r"^unmatchable$"
     TEMP_OFFLINE_PATTERN = r"^unmatchable$"
 
-    LEECH_HOSTER = False
     DIRECT_LINK = None
 
     @classmethod
--- a/src/pyload/plugins/base/simple_downloader.py
+++ b/src/pyload/plugins/base/simple_downloader.py
@@ -102,8 +102,6 @@ class SimpleDownloader(BaseDownloader):
     DISPOSITION = True
     LOGIN_ACCOUNT = False  #: Set to True to require account login
     LOGIN_PREMIUM = False  #: Set to True to require premium account login
-    #: Set to True to leech other hoster link (as defined in handle_multi method)
-    LEECH_HOSTER = False
     #: Set to encoding name if encoding value in http header is not correct
     TEXT_ENCODING = True
     # TRANSLATE_ERROR      = True
@@ -221,7 +219,6 @@ class SimpleDownloader(BaseDownloader):
     def _prepare(self):
         self.link = ""
         self.direct_dl = False
-        self.leech_dl = False
 
         if self.LOGIN_PREMIUM:
             self.no_fallback = True
@@ -240,27 +237,13 @@ class SimpleDownloader(BaseDownloader):
             if self.LINK_PREMIUM_PATTERN is None:
                 self.LINK_PREMIUM_PATTERN = self.LINK_PATTERN
 
-        if self.LEECH_HOSTER:
-            pattern = self.pyload.plugin_manager.hoster_plugins.get(self.classname)[
-                "pattern"
-            ]
-            if (
-                self.__pattern__ != pattern
-                and re.match(self.__pattern__, self.pyfile.url) is None
-            ):
-                self.leech_dl = True
-
-        if self.leech_dl:
-            self.direct_dl = False
-
         elif self.DIRECT_LINK is None:
             self.direct_dl = bool(self.premium)
 
         else:
             self.direct_dl = self.DIRECT_LINK
 
-        if not self.leech_dl:
-            self.pyfile.url = replace_patterns(self.pyfile.url, self.URL_REPLACEMENTS)
+        self.pyfile.url = replace_patterns(self.pyfile.url, self.URL_REPLACEMENTS)
 
     def _preload(self):
         if self.data:
@@ -273,38 +256,32 @@ class SimpleDownloader(BaseDownloader):
     def process(self, pyfile):
         self._prepare()
 
-        # TODO: Remove `handle_multi`, use MultiDownloader instead
-        if self.leech_dl:
-            self.log_info(self._("Processing as debrid download..."))
-            self.handle_multi(pyfile)
+        if not self.link and self.direct_dl:
+            self.log_info(self._("Looking for direct download link..."))
+            self.handle_direct(pyfile)
 
-        else:
-            if not self.link and self.direct_dl:
-                self.log_info(self._("Looking for direct download link..."))
-                self.handle_direct(pyfile)
-
-                if self.link:
-                    self.log_info(self._("Direct download link detected"))
-                else:
-                    self.log_info(self._("Direct download link not found"))
-
-            if not self.link:
-                self._preload()
-                self.check_errors()
+            if self.link:
+                self.log_info(self._("Direct download link detected"))
+            else:
+                self.log_info(self._("Direct download link not found"))
 
-                if self.info.get("status", 7) != 2:
-                    self.grab_info()
-                    self.check_status()
-                    self.check_duplicates()
-
-                out_of_traffic = self.CHECK_TRAFFIC and self.out_of_traffic()
-                if self.premium and not out_of_traffic:
-                    self.log_info(self._("Processing as premium download..."))
-                    self.handle_premium(pyfile)
-
-                elif not self.LOGIN_ACCOUNT or not out_of_traffic:
-                    self.log_info(self._("Processing as free download..."))
-                    self.handle_free(pyfile)
+        if not self.link:
+            self._preload()
+            self.check_errors()
+
+            if self.info.get("status", 7) != 2:
+                self.grab_info()
+                self.check_status()
+                self.check_duplicates()
+
+            out_of_traffic = self.CHECK_TRAFFIC and self.out_of_traffic()
+            if self.premium and not out_of_traffic:
+                self.log_info(self._("Processing as premium download..."))
+                self.handle_premium(pyfile)
+
+            elif not self.LOGIN_ACCOUNT or not out_of_traffic:
+                self.log_info(self._("Processing as free download..."))
+                self.handle_free(pyfile)
 
         if self.link and not self.last_download:
             self.log_info(self._("Downloading file..."))
@@ -486,9 +463,6 @@ class SimpleDownloader(BaseDownloader):
     def handle_direct(self, pyfile):
         self.link = pyfile.url if self.isresource(pyfile.url) else None
 
-    def handle_multi(self, pyfile):  #: Multi-hoster handler
-        pass
-
     def handle_free(self, pyfile):
         if not self.LINK_FREE_PATTERN:
             self.fail(self._("Free download not implemented"))
--- a/src/pyload/plugins/base/xfs_downloader.py
+++ b/src/pyload/plugins/base/xfs_downloader.py
@@ -41,8 +41,6 @@ class XFSDownloader(SimpleDownloader):
     PLUGIN_DOMAIN = None
 
     DIRECT_LINK = None
-    # NOTE: hould be set to `False` by default for safe, but I am lazy...
-    LEECH_HOSTER = True
 
     NAME_PATTERN = r'(Filename[ ]*:[ ]*</b>(</td><td nowrap>)?|name="fname"[ ]+value="|<[\w^_]+ class="(file)?name">)\s*(?P<N>.+?)(\s*<|")'
     SIZE_PATTERN = r'(Size[ ]*:[ ]*</b>(</td><td>)?|File:.*>|</font>\s*\(|<[\w^_]+ class="size">)\s*(?P<S>[\d.,]+)\s*(?P<U>[\w^_]+)'
@@ -129,62 +127,6 @@ class XFSDownloader(SimpleDownloader):
     def handle_premium(self, pyfile):
         return self.handle_free(pyfile)
 
-    def handle_multi(self, pyfile):
-        if not self.account:
-            self.fail(
-                self._("Only registered or premium users can use url leech feature")
-            )
-
-        #: Only tested with easybytez.com
-        self.data = self.load("http://www.{}/".format(self.PLUGIN_DOMAIN))
-
-        action, inputs = self.parse_html_form()
-
-        upload_id = "{:012}".format(int(random.random() * 10 ** 12))
-        action += upload_id + "&js_on=1&utype=prem&upload_type=url"
-
-        inputs["tos"] = "1"
-        inputs["url_mass"] = pyfile.url
-        inputs["up1oad_type"] = "url"
-
-        self.log_debug(action, inputs)
-
-        #: Wait for file to upload to easybytez.com
-        self.req.set_option("timeout", 600)
-
-        self.data = self.load(action, post=inputs)
-
-        self.check_errors()
-
-        action, inputs = self.parse_html_form("F1")
-        if not inputs:
-            self.retry(msg=self.info.get("error") or self._("TEXTAREA F1 not found"))
-
-        self.log_debug(inputs)
-
-        stmsg = inputs["st"]
-
-        if stmsg == "OK":
-            self.data = self.load(action, post=inputs)
-
-        elif "Can not leech file" in stmsg:
-            self.retry(20, timedelta(minutes=3).total_seconds(), self._("Can not leech file"))
-
-        elif "today" in stmsg:
-            self.retry(
-                wait=seconds.to_midnight(),
-                msg=self._("You've used all Leech traffic today"),
-            )
-
-        else:
-            self.fail(stmsg)
-
-        m = search_pattern(self.LINK_LEECH_PATTERN, self.data)
-        if m is None:
-            self.error(self._("LINK_LEECH_PATTERN not found"))
-
-        self.link = self.load(m.group(1), just_header=True).get("location")
-
     def _post_parameters(self):
         if self.FORM_PATTERN or self.FORM_INPUTS_MAP:
             action, inputs = self.parse_html_form(
